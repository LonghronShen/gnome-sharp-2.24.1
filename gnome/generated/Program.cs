// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gnome {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public class Program : GLib.Object {

		[Obsolete]
		protected Program(GLib.GType gtype) : base(gtype) {}
		public Program(IntPtr raw) : base(raw) {}

		protected Program() : base(IntPtr.Zero)
		{
			CreateNativeObject (new string [0], new GLib.Value [0]);
		}

		[GLib.Property ("gnome-path")]
		public string GnomePath {
			get {
				GLib.Value val = GetProperty ("gnome-path");
				string ret = (string) val;
				val.Dispose ();
				return ret;
			}
		}

		[GLib.Property ("gnome-libdir")]
		public string GnomeLibdir {
			get {
				GLib.Value val = GetProperty ("gnome-libdir");
				string ret = (string) val;
				val.Dispose ();
				return ret;
			}
		}

		[GLib.Property ("gnome-datadir")]
		public string GnomeDatadir {
			get {
				GLib.Value val = GetProperty ("gnome-datadir");
				string ret = (string) val;
				val.Dispose ();
				return ret;
			}
		}

		[GLib.Property ("app-prefix")]
		public string AppPrefix {
			get {
				GLib.Value val = GetProperty ("app-prefix");
				string ret = (string) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("app-prefix", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("gnome-prefix")]
		public string GnomePrefix {
			get {
				GLib.Value val = GetProperty ("gnome-prefix");
				string ret = (string) val;
				val.Dispose ();
				return ret;
			}
		}

		[GLib.Property ("espeaker")]
		public string Espeaker {
			get {
				GLib.Value val = GetProperty ("espeaker");
				string ret = (string) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("espeaker", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("app-datadir")]
		public string AppDatadir {
			get {
				GLib.Value val = GetProperty ("app-datadir");
				string ret = (string) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("app-datadir", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("enable-sound")]
		public bool EnableSound {
			get {
				GLib.Value val = GetProperty ("enable-sound");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("enable-sound", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("create-directories")]
		public bool CreateDirectories {
			get {
				GLib.Value val = GetProperty ("create-directories");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
		}

		[GLib.Property ("app-sysconfdir")]
		public string AppSysconfdir {
			get {
				GLib.Value val = GetProperty ("app-sysconfdir");
				string ret = (string) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("app-sysconfdir", val);
				val.Dispose ();
			}
		}

		[GLib.Property ("goption-context")]
		public IntPtr GoptionContext {
			get {
				GLib.Value val = GetProperty ("goption-context");
				IntPtr ret = (IntPtr) val;
				val.Dispose ();
				return ret;
			}
		}

		[GLib.Property ("gnome-sysconfdir")]
		public string GnomeSysconfdir {
			get {
				GLib.Value val = GetProperty ("gnome-sysconfdir");
				string ret = (string) val;
				val.Dispose ();
				return ret;
			}
		}

		[DllImport("gnome-2", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gnome_program_get_app_id(IntPtr raw);

		[GLib.Property ("app-id")]
		public string AppId {
			get  {
				IntPtr raw_ret = gnome_program_get_app_id(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
		}

		[DllImport("gnome-2", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gnome_program_get_app_version(IntPtr raw);

		[GLib.Property ("app-version")]
		public string AppVersion {
			get  {
				IntPtr raw_ret = gnome_program_get_app_version(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
		}

		[DllImport("gnome-2", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gnome_program_get_human_readable_name(IntPtr raw);

		[GLib.Property ("human-readable-name")]
		public string HumanReadableName {
			get  {
				IntPtr raw_ret = gnome_program_get_human_readable_name(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
		}

		[GLib.Property ("popt-context")]
		public IntPtr PoptContext {
			get {
				GLib.Value val = GetProperty ("popt-context");
				IntPtr ret = (IntPtr) val;
				val.Dispose ();
				return ret;
			}
		}

		[GLib.Property ("app-libdir")]
		public string AppLibdir {
			get {
				GLib.Value val = GetProperty ("app-libdir");
				string ret = (string) val;
				val.Dispose ();
				return ret;
			}
			set {
				GLib.Value val = new GLib.Value(value);
				SetProperty("app-libdir", val);
				val.Dispose ();
			}
		}

		[DllImport("gnome-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gnome_program_parse_args(IntPtr raw);

		[Obsolete]
		public void ParseArgs() {
			gnome_program_parse_args(Handle);
		}

		[DllImport("gnome-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gnome_program_postinit(IntPtr raw);

		[Obsolete]
		public void Postinit() {
			gnome_program_postinit(Handle);
		}

		[DllImport("gnome-2", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gnome_program_module_load(IntPtr mod_name);

		public static Gnome.ModuleInfo ModuleLoad(string mod_name) {
			IntPtr native_mod_name = GLib.Marshaller.StringToPtrGStrdup (mod_name);
			IntPtr raw_ret = gnome_program_module_load(native_mod_name);
			Gnome.ModuleInfo ret = raw_ret == IntPtr.Zero ? null : (Gnome.ModuleInfo) GLib.Opaque.GetOpaque (raw_ret, typeof (Gnome.ModuleInfo), false);
			GLib.Marshaller.Free (native_mod_name);
			return ret;
		}

		[DllImport("gnome-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gnome_program_module_register(IntPtr module_info);

		public static void ModuleRegister(Gnome.ModuleInfo module_info) {
			gnome_program_module_register(module_info == null ? IntPtr.Zero : module_info.Handle);
		}

		[DllImport("gnome-2", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gnome_program_initv(IntPtr type, IntPtr app_id, IntPtr app_version, IntPtr module_info, int argc, IntPtr argv, IntPtr first_property_name, IntPtr args);

		public static Gnome.Program Initv(GLib.GType type, string app_id, string app_version, Gnome.ModuleInfo module_info, int argc, string argv, string first_property_name, IntPtr args) {
			IntPtr native_app_id = GLib.Marshaller.StringToPtrGStrdup (app_id);
			IntPtr native_app_version = GLib.Marshaller.StringToPtrGStrdup (app_version);
			IntPtr native_first_property_name = GLib.Marshaller.StringToPtrGStrdup (first_property_name);
			IntPtr raw_ret = gnome_program_initv(type.Val, native_app_id, native_app_version, module_info == null ? IntPtr.Zero : module_info.Handle, argc, GLib.Marshaller.StringToPtrGStrdup(argv), native_first_property_name, args);
			Gnome.Program ret = GLib.Object.GetObject(raw_ret) as Gnome.Program;
			GLib.Marshaller.Free (native_app_id);
			GLib.Marshaller.Free (native_app_version);
			GLib.Marshaller.Free (native_first_property_name);
			return ret;
		}

		[DllImport("gnome-2", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gnome_program_locate_file(IntPtr raw, int domain, IntPtr file_name, bool only_if_exists, IntPtr ret_locations);

		public string LocateFile(Gnome.FileDomain domain, string file_name, bool only_if_exists, GLib.SList ret_locations) {
			IntPtr native_file_name = GLib.Marshaller.StringToPtrGStrdup (file_name);
			IntPtr raw_ret = gnome_program_locate_file(Handle, (int) domain, native_file_name, only_if_exists, ret_locations == null ? IntPtr.Zero : ret_locations.Handle);
			string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
			GLib.Marshaller.Free (native_file_name);
			return ret;
		}

		[DllImport("gnome-2", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gnome_program_module_registered(IntPtr module_info);

		public static bool ModuleRegistered(Gnome.ModuleInfo module_info) {
			bool raw_ret = gnome_program_module_registered(module_info == null ? IntPtr.Zero : module_info.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("gnome-2", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gnome_program_get();

		public static Gnome.Program Get() {
			IntPtr raw_ret = gnome_program_get();
			Gnome.Program ret = GLib.Object.GetObject(raw_ret) as Gnome.Program;
			return ret;
		}

		[DllImport("gnome-2", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gnome_program_get_type();

		public static new GLib.GType GType { 
			get {
				IntPtr raw_ret = gnome_program_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

#endregion
#region Customized extensions
#line 1 "Program.custom"
//
// Gnome.Program.custom - Gnome Program class customizations
//
// Author: Rachel Hestilow <hestilow@ximian.com>
//
// Copyright (C) 2002 Rachel Hestilow
//
// This code is inserted after the automatically generated code.
//
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General 
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.

	
[DllImport("libgobject-2.0-0.dll")]
static extern void g_type_init ();

[StructLayout(LayoutKind.Sequential)]
struct PropertyArg {
	public string name;
	public GLib.Value value;
}

[DllImport("gnomesharpglue-2")]
static extern System.IntPtr
gtksharp_gnome_program_init (string app_id, string app_version, IntPtr module, int argc, IntPtr argv, int nargs, PropertyArg[] args);

public Program (string app_id, string app_version, ModuleInfo module, string[] argv, params object[] props) : base (IntPtr.Zero)
{
	if (app_id.IndexOf (" ") > 0)
		throw new ArgumentException ("app_id argument can't contain spaces.");

	int nargs = props.Length / 2;
	PropertyArg[] args = new PropertyArg[nargs];
	GLib.Value[] vals = new GLib.Value[nargs];
	string[] new_argv = new string[argv.Length + 1];
	
	g_type_init ();

	for (int i = 0; i < nargs; i++)
	{
		args[i].name = (string) props[i * 2];
		GLib.Value value;
		// FIXME: handle more types
		object prop = props[i * 2 + 1];
		Type type = prop.GetType ();
		if (type == "hello".GetType ())
			value = new GLib.Value ((string) prop);
		else if (type == true.GetType ())
			value = new GLib.Value ((bool) prop);
		else
			value = GLib.Value.Empty;
		vals[i] = value;
		args[i].value = value; 
	}
	
	/* FIXME: Is there a way to access this in .NET? */ 
	new_argv[0] = app_id;
	Array.Copy (argv, 0, new_argv, 1, argv.Length);

	GLib.Argv gargv = new GLib.Argv (new_argv, false);
	Raw = gtksharp_gnome_program_init (app_id, app_version, module.Handle, new_argv.Length, gargv.Handle, nargs, args);
	PersistentData["glib_argv"] = gargv;

	//
	// Dynamically reset the signal handlers, because Gnome overwrites them
	//
	Type mono_runtime_type = Type.GetType ("Mono.Runtime");
	if (mono_runtime_type != null){
		object [] iargs = new object [0];
		System.Reflection.MethodInfo mi = mono_runtime_type.GetMethod ("InstallSignalHandlers", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Static);
	
		mi.Invoke (null, iargs);
	}

	HardenRef ();
}

void HardenRef ()
{
	// GnomeProgram installs an atexit handler which unrefs the instance, 
	// playing havoc with the toggle_ref notification. so we hack around
	// it here.
	System.Type t = typeof (GLib.Object);
	System.Reflection.MethodInfo harden_method = t.GetMethod ("Harden", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);
	harden_method.Invoke (this, null);
}

public void Run ()
{
	Gtk.Application.Run ();
}

public void Quit ()
{
	Gtk.Application.Quit ();
}



#endregion
	}
}
