// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gnome {

	using System;
	using System.Collections;
	using System.Runtime.InteropServices;

#region Autogenerated code
	[Obsolete]
	public class Druid : Gtk.Container {

		[Obsolete]
		protected Druid(GLib.GType gtype) : base(gtype) {}
		public Druid(IntPtr raw) : base(raw) {}

		[DllImport("gnomeui-2", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gnome_druid_new();

		public Druid () : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Druid)) {
				CreateNativeObject (new string [0], new GLib.Value[0]);
				return;
			}
			Raw = gnome_druid_new();
		}

		[DllImport("gnomeui-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gnome_druid_set_show_help(IntPtr raw, bool show_help);

		[GLib.Property ("show_help")]
		public bool ShowHelp {
			get {
				GLib.Value val = GetProperty ("show_help");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
			set  {
				gnome_druid_set_show_help(Handle, value);
			}
		}

		[DllImport("gnomeui-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gnome_druid_set_show_finish(IntPtr raw, bool show_finish);

		[GLib.Property ("show_finish")]
		public bool ShowFinish {
			get {
				GLib.Value val = GetProperty ("show_finish");
				bool ret = (bool) val;
				val.Dispose ();
				return ret;
			}
			set  {
				gnome_druid_set_show_finish(Handle, value);
			}
		}

		[DllImport ("gnomesharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		extern static uint gnomesharp_gnome_druid_get_finish_offset ();

		static uint finish_offset = gnomesharp_gnome_druid_get_finish_offset ();
		public Gtk.Button FinishButton {
			get {
				unsafe {
					IntPtr* raw_ptr = (IntPtr*)(((byte*)Handle) + finish_offset);
					return GLib.Object.GetObject((*raw_ptr)) as Gtk.Button;
				}
			}
		}

		[DllImport ("gnomesharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		extern static uint gnomesharp_gnome_druid_get_next_offset ();

		static uint next_offset = gnomesharp_gnome_druid_get_next_offset ();
		public Gtk.Button NextButton {
			get {
				unsafe {
					IntPtr* raw_ptr = (IntPtr*)(((byte*)Handle) + next_offset);
					return GLib.Object.GetObject((*raw_ptr)) as Gtk.Button;
				}
			}
		}

		[DllImport ("gnomesharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		extern static uint gnomesharp_gnome_druid_get_help_offset ();

		static uint help_offset = gnomesharp_gnome_druid_get_help_offset ();
		public Gtk.Button HelpButton {
			get {
				unsafe {
					IntPtr* raw_ptr = (IntPtr*)(((byte*)Handle) + help_offset);
					return GLib.Object.GetObject((*raw_ptr)) as Gtk.Button;
				}
			}
		}

		[DllImport ("gnomesharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		extern static uint gnomesharp_gnome_druid_get_back_offset ();

		static uint back_offset = gnomesharp_gnome_druid_get_back_offset ();
		public Gtk.Button BackButton {
			get {
				unsafe {
					IntPtr* raw_ptr = (IntPtr*)(((byte*)Handle) + back_offset);
					return GLib.Object.GetObject((*raw_ptr)) as Gtk.Button;
				}
			}
		}

		[DllImport ("gnomesharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		extern static uint gnomesharp_gnome_druid_get_cancel_offset ();

		static uint cancel_offset = gnomesharp_gnome_druid_get_cancel_offset ();
		public Gtk.Button CancelButton {
			get {
				unsafe {
					IntPtr* raw_ptr = (IntPtr*)(((byte*)Handle) + cancel_offset);
					return GLib.Object.GetObject((*raw_ptr)) as Gtk.Button;
				}
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void CancelVMDelegate (IntPtr druid);

		[DllImport ("gnomesharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gnomesharp_druid_override_cancel (IntPtr gtype, CancelVMDelegate cb);

		static CancelVMDelegate CancelVMCallback;

		static void cancel_cb (IntPtr druid)
		{
			try {
				Druid druid_managed = GLib.Object.GetObject (druid, false) as Druid;
				druid_managed.OnCancel ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideCancel (GLib.GType gtype)
		{
			if (CancelVMCallback == null)
				CancelVMCallback = new CancelVMDelegate (cancel_cb);
			gnomesharp_druid_override_cancel (gtype.Val, CancelVMCallback);
		}

		[DllImport ("gnomesharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gnomesharp_druid_base_cancel (IntPtr druid);

		[GLib.DefaultSignalHandler(Type=typeof(Gnome.Druid), ConnectionMethod="OverrideCancel")]
		protected virtual void OnCancel ()
		{
			gnomesharp_druid_base_cancel (Handle);
		}

		[GLib.Signal("cancel")]
		public event System.EventHandler Cancel {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "cancel");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "cancel");
				sig.RemoveDelegate (value);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void HelpVMDelegate (IntPtr druid);

		[DllImport ("gnomesharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gnomesharp_druid_override_help (IntPtr gtype, HelpVMDelegate cb);

		static HelpVMDelegate HelpVMCallback;

		static void help_cb (IntPtr druid)
		{
			try {
				Druid druid_managed = GLib.Object.GetObject (druid, false) as Druid;
				druid_managed.OnHelp ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		private static void OverrideHelp (GLib.GType gtype)
		{
			if (HelpVMCallback == null)
				HelpVMCallback = new HelpVMDelegate (help_cb);
			gnomesharp_druid_override_help (gtype.Val, HelpVMCallback);
		}

		[DllImport ("gnomesharpglue-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gnomesharp_druid_base_help (IntPtr druid);

		[GLib.DefaultSignalHandler(Type=typeof(Gnome.Druid), ConnectionMethod="OverrideHelp")]
		protected virtual void OnHelp ()
		{
			gnomesharp_druid_base_help (Handle);
		}

		[GLib.Signal("help")]
		public event System.EventHandler Help {
			add {
				GLib.Signal sig = GLib.Signal.Lookup (this, "help");
				sig.AddDelegate (value);
			}
			remove {
				GLib.Signal sig = GLib.Signal.Lookup (this, "help");
				sig.RemoveDelegate (value);
			}
		}

		[DllImport("gnomeui-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gnome_druid_set_page(IntPtr raw, IntPtr page);

		public Gnome.DruidPage Page { 
			set {
				gnome_druid_set_page(Handle, value == null ? IntPtr.Zero : value.Handle);
			}
		}

		[DllImport("gnomeui-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gnome_druid_construct_with_window(IntPtr raw, IntPtr title, IntPtr parent, bool close_on_cancel, out IntPtr window);

		public Gtk.Widget ConstructWithWindow(string title, Gtk.Window parent, bool close_on_cancel) {
			Gtk.Widget window;
			IntPtr native_title = GLib.Marshaller.StringToPtrGStrdup (title);
			IntPtr native_window;
			gnome_druid_construct_with_window(Handle, native_title, parent == null ? IntPtr.Zero : parent.Handle, close_on_cancel, out native_window);
			GLib.Marshaller.Free (native_title);
			window = GLib.Object.GetObject(native_window) as Gtk.Widget;
			return window;
		}

		[DllImport("gnomeui-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gnome_druid_append_page(IntPtr raw, IntPtr page);

		public void AppendPage(Gnome.DruidPage page) {
			gnome_druid_append_page(Handle, page == null ? IntPtr.Zero : page.Handle);
		}

		[DllImport("gnomeui-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gnome_druid_set_buttons_sensitive(IntPtr raw, bool back_sensitive, bool next_sensitive, bool cancel_sensitive, bool help_sensitive);

		public void SetButtonsSensitive(bool back_sensitive, bool next_sensitive, bool cancel_sensitive, bool help_sensitive) {
			gnome_druid_set_buttons_sensitive(Handle, back_sensitive, next_sensitive, cancel_sensitive, help_sensitive);
		}

		[DllImport("gnomeui-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gnome_druid_insert_page(IntPtr raw, IntPtr back_page, IntPtr page);

		public void InsertPage(Gnome.DruidPage back_page, Gnome.DruidPage page) {
			gnome_druid_insert_page(Handle, back_page == null ? IntPtr.Zero : back_page.Handle, page == null ? IntPtr.Zero : page.Handle);
		}

		[DllImport("gnomeui-2", CallingConvention = CallingConvention.Cdecl)]
		static extern void gnome_druid_prepend_page(IntPtr raw, IntPtr page);

		public void PrependPage(Gnome.DruidPage page) {
			gnome_druid_prepend_page(Handle, page == null ? IntPtr.Zero : page.Handle);
		}

		[DllImport("gnomeui-2", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gnome_druid_get_type();

		public static new GLib.GType GType { 
			get {
				IntPtr raw_ret = gnome_druid_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

#endregion
#region Customized extensions
#line 1 "Druid.custom"
// Druid.custom - Gnome.Druid customizations
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of version 2 of the Lesser GNU General 
// Public License as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the
// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA.

		[DllImport("gnomeui-2")]
		static extern IntPtr gnome_druid_new_with_window(IntPtr title, IntPtr parent, bool close_on_cancel, out IntPtr window);

		Gtk.Widget new_with_window (string title, Gtk.Widget parent, bool close_on_cancel)
		{
			IntPtr handle;
			IntPtr ntitle = GLib.Marshaller.StringToPtrGStrdup (title);
			Raw = gnome_druid_new_with_window (ntitle, parent == null ? IntPtr.Zero : parent.Handle, close_on_cancel, out handle);
			GLib.Marshaller.Free (ntitle);
			return GLib.Object.GetObject (handle) as Gtk.Widget;
		}

		public Druid (string title, bool close_on_cancel, out Gtk.Widget window) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Druid)) {
				CreateNativeObject (new string[0], new GLib.Value [0]);
				window = ConstructWithWindow (title, null, close_on_cancel);
				return;
			}
			window = new_with_window (title, null, close_on_cancel);
		}

		public Druid (string title, bool close_on_cancel) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Druid)) {
				CreateNativeObject (new string[0], new GLib.Value[0]);
				ConstructWithWindow (title, null, close_on_cancel);
				return;
			}
			new_with_window (title, null, close_on_cancel);
		}

		public Druid (string title, Gtk.Window parent, bool close_on_cancel) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Druid)) {
				CreateNativeObject (new string[0], new GLib.Value[0]);
				ConstructWithWindow (title, parent, close_on_cancel);
				return;
			}
			new_with_window (title, parent, close_on_cancel);
		}

		public Druid (string title, Gtk.Window parent, bool close_on_cancel, out Gtk.Widget window) : base (IntPtr.Zero)
		{
			if (GetType () != typeof (Druid)) {
				CreateNativeObject (new string[0], new GLib.Value[0]);
				window = ConstructWithWindow (title, parent, close_on_cancel);
				return;
			}
			window = new_with_window(title, parent, close_on_cancel);
                }


#endregion
	}
}
